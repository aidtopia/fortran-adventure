C   SCRATCH PROJECT TO CHECK OUT THE TRANSLATOR

      PROGRAM ADVTST
      IMPLICIT INTEGER(A-Z)
      SUM(X,Y)=X+Y
      PROD(X,Y)=X*Y
      T=3
      Q=SUM(PROD(2,T), PROD(2*T,2))
      TYPE 1,Q
1     FORMAT(' Q:', I5)
      STOP
      END


      SUBROUTINE HELLO
      TYPE 110
110   FORMAT(' HELLO')
      END


      SUBROUTINE BYE
      TYPE 210
210   FORMAT(' GOODBYE')
      END


      SUBROUTINE CONCLU(SUB)
      CALL SUB
      END


      SUBROUTINE DEMO3
      EXTERNAL BYE
      CALL HELLO
      CALL DEMO1
      CALL DEMO2
      CALL CONCLU(BYE)
      END


      SUBROUTINE DEMO1
      IMPLICIT INTEGER(A-Z)
      LOGICAL BAR

C   .AND. AND .OR. ARE IMPLEMENTED AS BITWISE OPERATORS, THUS FOO WILL BE -2.
      FOO=-1.AND.-2.OR.0
      VAR='FOO'
      IF(FOO)TYPE 50,VAR
      IF(FOO.EQ..TRUE.)TYPE 51,VAR

C   SINCE BAR IS LOGICAL, THE EXPRESSION RESULT IS CAST TO A LOGICAL BEFORE THE
C   ASSIGNMENT TO BAR, AND THUS BAR SHOULD BE EXACTLY .TRUE. OR .FALSE.
      BAR=-1.AND.-2.OR.0
      VAR='BAR'
      IF(BAR)TYPE 50,VAR
      IF(BAR.EQ..TRUE.)TYPE 51,VAR
      RETURN
50    FORMAT(' ', A5, ' IS TRUE-ISH')
51    FORMAT(' IN FACT, ', A5, ' IS EXACTLY .TRUE.')
      END


C   CAN WE USE A LOCAL ARRAY FOR TEMPORARY VALUES THAT MUST BE PASSED BY
C   REFERENCE INSTEAD OF USING THE HOKEY TMP_PUSH/TEMP_POP MACROS?  GETTING THE
C   TEMP VALUES INTO THE CORE MEMORY COULD SIMPLIFY HOW WE WORK WITH VARIABLES
C   BY USING INDICES INSTEAD OF POINTERS.

C   WE NEED TO FIGURE OUT:
C     1. HOW MANY SLOTS TO RESERVE
C
C        PROPOSAL:  COUNT HOW MANY TEMPS ARE NEEDED FOR EACH STATEMENT, AND
C        USE THE MAXIMUM COUNT FOR ALL OF THE STATEMENTS IN THE SUBPROGRAM.
C
C        THIS SHOULD BE BOUNDED BECAUSE RECURSION IS NOT PERMITTED AND ALL
C        VARIABLES COME FROM STATIC STORAGE.  TEMPS NEEDED THE CALLED OR INVOKED
C        SUBPROGRAM WOULD COME FROM THAT SUBPROGRAM'S OWN ARRAY OF TEMPORARIES.
C
C     2. HOW TO ALLOCATE THE SLOTS WHEN TRANSLATING AN EXPRESSION
C
C        PROPOSAL:  START THE COUNTER AT 0 AND INCREMENT IT AS EACH NEW
C        TEMPORARY IS NEEDED.  WHEN THE STATEMENT IS COMPLETED, RESET THE
C        COUNTER TO 0.
C
C        IF THAT SOUNDS A LOT LIKE THE SOLUTION TO 1, I THINK THAT'S A GOOD
C        SIGN.
C
C     3. HOW TO DEAL WITH ARITHMETIC FUNCTIONS
C
C        WE GOT PRETTY FAR LETTING THE C PREPROCESSOR HANDLE THE ARITHMETIC
C        FUNCTIONS BY TRANSLATING THEM INTO MACROS.  I SEE TWO OPTIONS, BUT I
C        DON'T YET HAVE A PROPOSAL.
C
C        OPTION 1:  EXPAND THE ARITHMETIC FUNCTIONS DIRECTLY INPLACE IN THE
C        TRANSLATOR.  THEN THE TEMPORARIES IT REQUIRES WOULD BE ACCOUNTED FOR
C        FOR IN THE CURRENT SUBPROGRAM.  ESSENTIALLY WE'D IMPLEMENT OUR OWN
C        MACRO EXPANDER, WHICH MAY OR MAY NOT BE TOO DIFFICULT.  IT COULD LEAD
C        TO BLOATED CODE, THOUGH.
C
C        OPTION 2:  TURN ARITHMETIC FUNCTIONS INTO FULL-FLEDGED SUBPROGRAMS.
C        THIS WOULD BE CHALLENGING BECAUSE THE FUNCTIONS SHOULD EXIST ONLY
C        IN THE SCOPE OF THE DEFINING SUBPROGRAM AND BECAUSE THE ARITHMETIC
C        FUNCTIONS HAVE ACCESS TO LOCAL VARIABLES OF THE DEFINING SUBPROGRAM.
C        WE'RE NOT SET UP TO HANDLE SITUATIONS LIKE THOSE.
C
C     4. HOW DOES THIS INTERACT WITH RETURNING VIA AN OUTPUT PARAMETER?
C
C        FUNCTIONS CURRENTLY STASH THE VALUE TO BE RETURNED IN A SPECIAL RETVAL
C        VARIABLE, WHICH IS ESSENTIALLY A SPECIALLY DESIGNATED LOCAL VARIABLE
C        THAT IS THEN RETURNED FROM THE C FUNCTION.  THE INVOKING CODE THEN
C        COPIES THE RETURN VALUE TO THE INTENDED DESTINATION (WHICH MIGHT BE A
C        TEMPORARY).
C
C        WHY NOT MAKE RETURN VALUES INTO SPECIAL ARGUMENTS?  SINCE ARGUMENTS ARE
C        PASSED BY REFERENCE, THE RESULT COULD BE WRITTEN DIRECTLY TO THE FINAL
C        DESTINATION, MAKING THE CODE SIMPLER AND MORE EFFICIENT.
C
C        IF WE TAKE RETURN BY REFERENCE, DOES THAT AFFECT OUR PLAN FOR
C        TEMPORARIES?
C
C   HERE'S SOME TEST CODE WITH NESTED FUNCTION CALLS TO ANALYZE.
      
      SUBROUTINE DEMO2
      IMPLICIT INTEGER(A-Z)
1     TYPE 10
10    FORMAT(' ENTER AN INTEGER:')
      ACCEPT 20,NUM
20    FORMAT(I)
      RESULT = ISFOUR(NUM)
      TYPE 30,NUM,RESULT
30    FORMAT(' ', I5, ' IS 4: ', L1)
      IF(NUM.EQ.-1.OR..NOT.NONZRO(NUM))GOTO 4
      GOTO 1
4     TYPE 40
40    FORMAT(' THANKS FOR PLAYING.')
      RETURN
      END


      INTEGER FUNCTION HALF(X)
      IMPLICIT INTEGER(A-Z)
      HALF=X/2
      RETURN
      END
      

      INTEGER FUNCTION SQR(X)
      IMPLICIT INTEGER(A-Z)
      SQR=X*X
      RETURN
      END
      

      LOGICAL FUNCTION NONZRO(X)
      IMPLICIT INTEGER(A-Z)
      NONZRO=X.NE.0
      RETURN
      END
      

      LOGICAL FUNCTION ISFOUR(X)
      IMPLICIT INTEGER(A-Z)
      ISFOUR=SQR(HALF(X)).EQ.X.AND.NONZRO(X)
      RETURN
      END
